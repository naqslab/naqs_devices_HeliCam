"""
Labscript device driver for Heliotis HeliCam C3 camera.

The HeliCam is a high-speed 3D imaging camera from Heliotis that can be
controlled via the libHeLIC library. This device driver allows it to be
integrated into labscript experiments with hardware triggering support.

The camera supports various imaging modes including:

- Raw IQ (In-phase/Quadrature) data
- Intensity (HDR) imaging

.. :no-index:

"""

import sys
from labscript_utils import dedent
from labscript import TriggerableDevice, set_passed_properties
import numpy as np
import labscript_utils.h5_lock
import h5py

class HeliCam(TriggerableDevice):
    """Labscript device for the Heliotis HeliCam C3 3D lock-in camera.
    
    This camera is controlled via hardware trigger and the libHeLIC library.
    It supports various imaging modes including raw IQ, amplitude, and intensity
    measurements.
    """
    
    description = 'Heliotis HeliCam C3 Camera'
    # HeliCam C3 has a maximum sensor size, but depending on the mode it can be
    # less than 300x300. TODO: Document this.
    max_image_width = 300
    max_image_height = 300

    @set_passed_properties(
        property_names={
            "connection_table_properties": [
                "serial_number",
                "orientation",
                "pixel_size",
                "magnification",
                "manual_mode_camera_attributes",
                "mock",
            ],
            "device_properties": [
                "camera_attributes",
                "stop_acquisition_timeout",
                "exception_on_failed_shot",
                "saved_attribute_visibility_level"
            ],
        }
    )
    def __init__(
        self,
        name,
        parent_device,
        connection,
        serial_number,
        orientation=None,
        pixel_size=[1.0,1.0],
        magnification=1.0,
        trigger_edge_type='falling',
        trigger_duration=None,
        minimum_recovery_time=0.0,
        camera_attributes=None,
        manual_mode_camera_attributes=None,
        stop_acquisition_timeout=5.0,
        exception_on_failed_shot=True,
        saved_attribute_visibility_level='intermediate',
        mock=False,
        **kwargs
    ):
        """Initialize a HeliCam device for labscript.

        Args:
            name (str):
                Device name

            parent_device (IntermediateDevice):
                Device with digital outputs to be used to trigger acquisition

            connection (str):
                Name of digital output port on parent device.

            serial_number (str or int):
                String or integer (integer allows entering a hex literal) of the
                camera's serial number. This will be used to identify the camera.

            orientation (str, optional), default: `<name>`:
                Description of the camera's location or orientation. This will be used
                to determine the location in the shot file where the images will be
                saved. If not given, the device name will be used instead.

            pixel_size ([float, float], optional), default: `[1.0, 1.0]`:
                The x and y size of the pixels in micrometers. This can be used 
                in setting the scale in the BLACS image display as well as 
                extracted in lyse for analysis.

            magnification (float, optional), default: `1.0`:
                Imaging system magnification.

            trigger_edge_type (str), default: `'falling'`:
                The direction of the desired edges to be generated on the parent
                device's digital output used for triggering. Must be 'rising' or
                'falling'. Note that this only determines the edges created on the
                parent device, it does not program the camera to expect this type of
                edge. If required, one must configure the camera separately via
                `camera_attributes` to ensure it expects the type of edge being
                generated.

            trigger_duration (float or None), default: `None`:
                Duration of digital pulses to be generated by the parent device. This
                can also be specified as an argument to `expose()` - the value given
                here will be used only if nothing is passed to `expose()`.

            minimum_recovery_time (float), default: `0`:
                Minimum time between frames. This will be used for error checking during
                compilation.

            camera_attributes (dict, optional):
                Dictionary of camera attribute names and values to be programmed into
                the camera. The meaning of these attributes is model-specific and depends
                on the libHeLIC library. Common attributes include:
                
                - ``SensTqp``: Sensor integration time
                - ``SensNFrames``: Number of frames to acquire
                - ``CamMode``: Camera Mode, Currently supporting: (0=RAW_IQ, 7=HDR)
                - ``BSEnable``: Background subtraction enable
                - ``DdsGain``: DDS gain setting
                - ``TrigFreeExtN``: External trigger enable
                - ``TrigExtSrcSel``: External trigger source selection
                
                Attributes will be programmed in the order they appear in this
                dictionary. This can be important as some attributes may not be settable
                unless another attribute has been set first. After adding this device to
                your connection table, a dictionary of the camera's default attributes
                can be obtained from the BLACS tab, appropriate for copying and pasting
                into your connection table to customize the ones you are interested in.

            manual_mode_camera_attributes (dict, optional):
                Dictionary of attributes that will be programmed into the camera during
                manual mode, that differ from their values in ``camera_attributes``. This
                can be useful for example, to have software triggering during manual
                mode (allowing the acquisition of frames from the BLACS manual mode
                interface) but hardware triggering during buffered runs. Any attributes
                in this dictionary must also be present in ``camera_attributes``.

            stop_acquisition_timeout (float), default: `5.0`:
                How long, in seconds, to wait during :meth:`transition_to_buffered` for the
                acquisition of images to complete before giving up. Whilst all triggers
                should have been received, this can be used to allow for slow image
                download time.

            exception_on_failed_shot (bool), default: `True`:
                If acquisition does not complete within the given timeout after the end
                of a shot, whether to raise an exception. If False, instead prints a
                warning to stderr (visible in the terminal output pane in the BLACS
                tab), saves the images acquired so far, and continues. In the case of
                such a 'failed shot', the HDF5 attribute
                f['images'][orientation/name].attrs['failed_shot'] will be set to `True`
                (otherwise it is set to `False`). This attribute is accessible in the
                lyse dataframe as `df[orientation/name, 'failed_shot']`.

            saved_attribute_visibility_level (str or None), default: `'intermediate'`:
                The detail level of the camera attributes saved to the HDF5 file at the
                end of each shot. If None, no attributes will be saved. Must be one of
                `'simple'`, `'intermediate'`, `'advanced'`, or `None`. If `None`, no
                attributes will be saved.

            mock (bool, optional), default: `False`:
                For testing purposes, simulate a camera with fake data instead of
                communicating with actual hardware.

            **kwargs:
                Further keyword arguments to be passed to the `__init__` method of
                the parent class (TriggerableDevice).
        """
        self.trigger_edge_type = trigger_edge_type
        self.minimum_recovery_time = minimum_recovery_time
        self.trigger_duration = trigger_duration
        self.orientation = orientation
        self.pixel_size = pixel_size
        self.magnification = magnification
        if isinstance(serial_number, (str, bytes)):
            serial_number = int(serial_number, 16)
        self.serial_number = serial_number
        self.BLACS_connection = hex(self.serial_number)[2:].upper()
        if camera_attributes is None:
            camera_attributes = {}
        if manual_mode_camera_attributes is None:
            manual_mode_camera_attributes = {}
        for attr_name in manual_mode_camera_attributes:
            if attr_name not in camera_attributes:
                msg = f"""attribute '{attr_name}' is present in
                    manual_mode_camera_attributes but not in camera_attributes.
                    Attributes that are to differ between manual mode and buffered
                    mode must be present in both dictionaries."""
                raise ValueError(dedent(msg))
        valid_attr_levels = ('simple', 'intermediate', 'advanced', None)
        if saved_attribute_visibility_level not in valid_attr_levels:
            msg = "saved_attribute_visibility_level must be one of %s"
            raise ValueError(msg % valid_attr_levels)
        self.camera_attributes = camera_attributes
        self.manual_mode_camera_attributes = manual_mode_camera_attributes
        self.exposures = []
        TriggerableDevice.__init__(self, name, parent_device, connection, **kwargs)
        

    def expose(self, t, name, frametype='frame', trigger_duration=None):
        """Request an exposure at the given time.
        
        A trigger will be produced by the parent trigger object, with duration
        trigger_duration, or if not specified, of self.trigger_duration. The frame
        should have a `name`, and optionally a `frametype`, both strings. These
        determine where the image will be stored in the hdf5 file. `name` should be
        a description of the image being taken, such as "insitu_absorption" or
        "fluorescence" or similar. `frametype` is optional and is the type of frame
        being acquired, for imaging methods that involve multiple frames. For example
        an absorption image of atoms might have three frames: 'probe', 'atoms' and
        'background'. For this one might call expose three times with the same name,
        but three different frametypes.
        
        Args:
            t (float):
                Time in seconds at which to acquire the frame
            name (str):
                Name/description of the image
            frametype (str), default: `'frame'`:
                Type of frame being acquired
            trigger_duration (float or None), default: `None`:
                Duration of the trigger pulse. If not specified, uses self.trigger_duration
        
        Returns:
            float: The trigger duration used
        
        Raises:
            ValueError: If trigger_duration is not positive or not set
        """
        # Backward compatibility with code that calls expose with name as the first
        # argument and t as the second argument:
        if isinstance(t, str) and isinstance(name, (int, float)):
            msg = """expose() takes `t` as the first argument and `name` as the second
                argument, but was called with a string as the first argument and a
                number as the second. Swapping arguments for compatibility, but you are
                advised to modify your code to the correct argument order."""
            print(dedent(msg), file=sys.stderr)
            t, name = name, t
        if trigger_duration is None:
            trigger_duration = self.trigger_duration
        if trigger_duration is None:
            msg = """%s %s has not had an trigger_duration set as an instantiation
                argument, and none was specified for this exposure"""
            raise ValueError(dedent(msg) % (self.description, self.name))
        if not trigger_duration > 0:
            msg = "trigger_duration must be > 0, not %s" % str(trigger_duration)
            raise ValueError(msg)
        print(f"Triggering now at {t} for duration {trigger_duration}")
        self.trigger(t, trigger_duration)
        self.exposures.append((t, name, frametype, trigger_duration))
        return trigger_duration
    
    def frequency_to_tqp(self, freq):
        """
        Helper to get the TQP (Time Quarter Period).
        
        The camera API maps the allowed frequency range of (2, 250) KHz to 
        (0, 4095), with 4095 corresponding to the lower frequency limit.
        
        The documentation notes that the following formula assumes a sensor
        frequency of 70 MHz.
        This is hardcoded here because feasibly this value does not change.
        
        Args:
            freq (float): demodulation frequency in Hz
        Returns:
            tqp (int):
                Time Quarter Period
        """
        tqp = 70e6 / (8 * freq) - 30
        assert tqp < 4096, f"Rquested Frequency {freq} out of bounds (too low)"
        return int(tqp)
    
    def tqp_to_frequency(self, tqp: int):
        """
        Inversion of :meth:`naqs_devices.HeliCam.frequency_to_tqp`.
        
        Args:
            tqp (int):
                Time Quarter Period
        Returns:
            freq (float): demodulation frequency in Hz
        """
        freq = (70e6 / 8) * (1 / (tqp + 30))
        return freq # in Hz

    def generate_code(self, hdf5_file):
        """Generate code for the device and save exposure information to HDF5.
        
        This method performs validation checks on the device configuration and
        stores the exposure data in the HDF5 file for use by the BLACS worker.
        
        Args:
            hdf5_file (h5py.File):
                The HDF5 file object to write to
        """
        self.do_checks()
        
        vlenstr = h5py.special_dtype(vlen=str)
        table_dtypes = [
            ('t', float),
            ('name', vlenstr),
            ('frametype', vlenstr),
            ('trigger_duration', float),
        ]
        data = np.array(self.exposures, dtype=table_dtypes)
        group = self.init_device_group(hdf5_file)
        if self.exposures:
            group.create_dataset('EXPOSURES', data=data)
